class Solution {
public:
    
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // for the special case
        if(lists.size() == 0) 
            return NULL;
        
        priority_queue<int, vector<int>, greater<int>> que;
        
        for(int i=0; i<lists.size(); i++){
            ListNode* temp = lists[i];
            while(temp!=NULL){
                que.push(temp->val);
                temp = temp->next;
            }
        }
        // here we need to create two ListNode, one for the returning answer;
        // answer one is to traverse
        ListNode* dummy = new ListNode();
        ListNode* ans = dummy;
        
        while(!que.empty()){
            int value = que.top();
            que.pop();
            // for each time, we need to create a new node to store the value of the top of the queue
            ListNode* temp = new ListNode(value);
            ans->next = temp;
            ans = ans->next;
        }
        return dummy->next;
    }
};